Towards a Two-Tier Hierarchical Infrastructure:
An Oine Payment System for Central Bank Digital Currencies
Mihai Christodorescu*, Wanyun Catherine Gu**, Ranjit Kumaresan*, Mohsen Minaei*, Mustafa Ozdayi*, Benjamin
Price**, Srinivasan Raghuraman*, Muhammad Saad*, Cuy Sheeld**, Minghua Xu*, and Mahdi Zamani*
*Visa Research, Palo Alto, CA
**Visa Crypto Product, Palo Alto, CA
Abstract
Digital payments traditionally rely on online communications with several intermediaries such as
banks, payment networks, and payment processors in order to authorize and process payment trans-
actions. While these communication networks are designed to be highly available with continuous
uptime, there may be times when an end-user experiences little or no access to network connectivity.
The growing interest in digital forms of payments has led central banks around the world to ex-
plore the possibility of issuing a new type of central-bank money, known as central bank digital cur-
rency (CBDC). To facilitate the secure issuance and transfer of CBDC, we envision a CBDC design under
a two-tier hierarchical trust infrastructure , which is implemented using public-key cryptography with
the central bank as the root certicate authority for generating digital signatures, and other nancial
institutions as intermediate certicate authorities. One important design feature for CBDC that can be
developed under this hierarchical trust infrastructure is an oine capability to create secure point-
to-point oine payments through the use of authorized hardware. An oine capability for CBDC as
digital cash can create a resilient payment system for consumers and businesses to transact in any
situation.
In this paper, we propose an oine payment system (OPS) protocol for CBDC that allows a user to
make digital payments to another user while both users are temporarily oine and unable to connect
to payment intermediaries (or even the Internet). OPS can be used to instantly complete a transaction
involving any form of digital currency over a point-to-point channel without communicating with any
payment intermediary, achieving virtually unbounded throughput and real-time transaction latency.
One needs to ensure funds cannot be double-spent during oine payments as no trusted intermediary
is present in the payment loop to protect against replay of payment transactions. Our OPS protocol
prevents double-spending by relying on digital signatures generated bytrusted execution environments
(TEEs) which are already available on most computer devices, including smartphones and tablets. While
a TEE brings the primary point of trust to an oine device, an OPS system requires several crypto-
graphic protocols to enable the secure exchange of funds between multiple TEE-enabled devices, and
hence a reliable nancial ecosystem that can securely support CBDC at scale.
1
arXiv:2012.08003v1 [cs.CR] 14 Dec 2020
Contents
1 Introduction 3
1.1 Our Contribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.2 Overview of Our Solution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
2 Our Model 7
2.1 Problem Denition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.2 Threat Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.3 TEE Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
3 The OPS Protocol 9
3.1 Client Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3.2 OPS TA Registration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
3.3 OPS TA Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
3.4 Deposit and Withdraw Protocols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.5 Oine Payment Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
3.6 Claim and Collect Protocols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2
1 Introduction
Digital payments today represent an account-based system of debiting and crediting accounts operated
by the nancial institutions, where the ownership of a payment account is tied to a users public identity.
With the emergence of distributed ledger technology, there has been growing interest in a new form of
token-based digital payment, where the token itself represents the medium of exchange or money, and
the ownership of the token is determined by a users access to a private cryptographic key that provides
access to the users digital wallet . Access to these wallets are typically facilitated by entities, known as
wallet providers , that oer secure access to the cryptographic keys as well as some banking and other
nancial capabilities [13].
The growing interest in token-based payments have led central banks around the world to explore the
possibility of issuing a new type of central-bank money, known as central bank digital currency (CBDC) .
Some of these central banks have proposed designs that would issue this new money in the form of cryp-
tographic tokens backed directly by central bank reserves to enable consumers and businesses to make
payments in the form of digital cash [46].
In a CBDC model, the money in transit should remain the liability of its trusted issuer (e.g., a central
bank in the case of CBDC), meaning that its value is always guaranteed by the issuer as long as the recip-
ient can easily verify the authenticity of the money. This ensures that (1) the money was issued properly
according to a specic set of rules (aka, a monetary policy that has parallels to the existing nancial sys-
tem) set by the issuer, and (2) the money maintained its value in transit (i.e., was neither double spent
nor counterfeited). In the digital world, this can be implemented using public-key cryptography, where
the money in transit carries a digital signature that can only be generated directly by the central bank or
indirectly by one of the central banks certied delegates. Any recipient of the money can then simply au-
thenticate it by verifying the signature against the public key of the central bank and/or the certicate of its
trusted delegate. Public-key cryptography could oer signicant advantages for security and compliance
over cash.
We envision a two-tier hierarchical trust infrastructure delivered through certied delegation, which
allows the central bank to outsource the complexity of managing digital certicates for CBDC tokens to a
set of potentially regulated, permissioned entities that derive their authority from the central bank, through
a hierarchy of digital certicates originated from the central back at the root. This hierarchical trust design
resembles the hierarchy of certicate authorities (CAs) in a public-key infrastructure (PKI) [7] that plays a
vital role in enabling the secure transfer of information over the Internet. A PKI model for CBDC can
signicantly facilitate the secure issuance and transfer of CBDC funds with the central bank serving as the
root CA and supervised nancial institutions (FIs) serving as intermediate CAs under regulatory oversight.
These intermediate CAs have two roles: (1) Vetting wallet providers based on regulatory compliance; (2)
Issuing digital certicates to vetted wallet providers to facilitate CBDC payments securely.
The core advantage of the two-tier model is that it decouples the certicate infrastructure (Tier 1) from
the critical latency path of CBDC payments (Tier 2), allowing wallet providers such as banks and other
FIs to securely process CBDC payments at a high scale without imposing extra overhead on the highly-
protected PKI nodes. This is a particularly relevant question at the heart of the current CBDC debate.
In the past year, several central banks have begun to research and ask how oine CBDC payments
could occur [4, 810]. An important feature that can be developed under the hierarchical trust
infrastructure for CBDC is an oline capability to create secure point-to-point oline pay-
ments using authorized hardware. An oine protocol can be a potential feature of CBDC by bringing
the primary point of trust to an oine device under this infrastructure. CBDC as digital cash can move
instantly across multiple payment rails and condition without necessarily needing to directly involve any
intermediary during transfers. For example, if the sender and the recipient of a payment have relationships
with dierent wallet providers, they should still be able to transact with each other instantly in an ad-hoc,
3
point-to-point fashion without communicating with their wallet providers. This enables a signicantly
higher throughput as payments can still happen under congested network conditions. Moreover, the de-
sign provides a higher level of privacy to the clients by avoiding the need to share unnecessary payment
information with the intermediaries.
One technical challenge in creating secure oine payments is to protect the system from nancial
crimes and to avoid exposing either the buyer, seller, or the central bank to the risk that the payment may
not ultimately be settled [4]. Existing card payment networks such as Visa and Mastercard can provide
some form of oine payments for situations where the acceptance device (e.g., a card terminal) cannot
connect to payment providers for authorization in real time [11,12]. Payments without issuer authorization
require the merchant to bear some counterparty risk because the payer may not actually have the necessary
funds to fulll the transaction [13].
Would it be possible to allow oine payments between two parties without exposing counterparty
risk on either party?
Today, most mobile devices (e.g., smartphones and tablets) are equipped withsecure hardware to store
keys and other sensitive material that can only be accessed through strong user authentication measures
(e.g., biometrics). It has been shown that compromising these hardware-protected mobile devices without
help from their manufacturers is dicult [14]. This can potentially make mobile devices a viable option
to store the users CBDC funds and to issue oine payments using hardware-protected credentials provi-
sioned by the central bank or one of its delegates. As long as the secure hardware remains secure, (1) the
keys for signing oine payments are protected from malicious access, and (2) the same funds cannot be
spent oine more than once (i.e., no double spending).
While secure hardware provides a simple and ecient medium for delegation of trust in the digital
setting [14], the possibility of device compromise would not only expose the involved users to the risk of
funds loss but also could, at a much larger scale, jeopardize the functionality of the entire CBDC ecosystem.
In a recent study, Allen et al. [15] identify three main challenges in the use of secure hardware. First, there
is a strong economic incentive for users to compromise their secure hardware in order to counterfeit CBDC
funds. Second, compromising one device could allow a user to double spend funds an unlimited number
of times (i.e., by default there is no graceful degradation ). And third, a users funds could be totally lost in
case of device loss (due to, e.g., damage or failure).
We observe that these challenges are not exclusive to digital oine payments and are applicable to vir-
tually any form of oine payments, including physical cash. Therefore, we envision that measures similar
to those used for physical cash could be employed to protect the security of CBDC in an oine setting
while still maintaining the practical benets of oine payments. In this paper, we initiate the formal study
of oine digital payments and propose a system that provides the basic functionalities for oine payments
assuming secure hardware cannot be compromised. In subsequent work, we will explore extended tech-
niques for oine payments to alleviate the above challenges by addressing economic incentives, graceful
degradation, and funds recovery.
1.1 Our Contribution
In this paper, we initiate the study of oine digital payments by dening the notion of anoine payment
system (OPS) that allows a user (e.g., a customer) to make digital payments in CBDCs to another user (e.g.,
a merchant) while both users are temporarily oine from payment intermediaries (or even the Internet).
We then construct the rst OPS protocol that allows point-to-point authorization of oine payments using
open source technology and public key infrastructure to signicantly reduce the overhead of onboarding
new participants compared to existing digital payment systems. Once provisioned, OPS wallets can se-
curely sign and transmit transaction messages directly with each other over any communication channel
4
they prefer without requiring an intermediary to authorize and settle it. Recipients can submit signed, of-
ine payment messages to an authorized wallet provider with guaranteed settlement of those transactions
in order to withdraw funds from the oine payment system.
1.2 Overview of Our Solution
Consider two clients A and B who hold online accounts with a server S. We assume an account maintains
information about the amount of money (aka, balance) that the client holds atS. We assume that the server
is a digital wallet provider that has already obtained a digital certicate from the central bank through the
hierarchical trust infrastructure for CBDC, as described in Section 1. This certicate can be used to attest
to the clients that S is a trusted entity. In the rest of this paper, we describe the oine payment protocol
that happens between the clients and the trusted server.
We assume a clients account maintains information about the amount of money (aka, balance) that the
client holds at S. The goal of our OPS protocol is to allow clientA (aka, the sender) to pay client B (aka, the
receiver) an amount of money denoted by from As account withS without either client communicating
with S during the payment. We assume A (or any other client who wishes to send money) owns a secure
device DA that can securely store data and execute code via atrusted execution environment (TEE) . However,
we do not require B (or any other client who only wants to receive money) to own a secure device. In the
following, we rst describe our TEE model and the main components of our protocol. Next, we briey
describe the main OPS protocols to set up the clients and perform oine payments.
TEE Model. A TEE is a software stack stored on a read-only memory within a secure device. This soft-
ware stack should adhere to privacy, security, and high software development standards which are already
adopted by most secure devices today. The stack consists of a set of resources to access the secure device,
a trusted operating system (TOS) that provides developer access to the underlying secure device, and one or
more trusted applications (TA) that implement application-specic functionalities to be executed securely
by the TEE (see Figure 4).
Untrusted Applications. Every client (with or without TEE) has an application-specic untrusted ap-
plication (UA) that resides in the untrusted region of the device and thus could be malicious. A benign
UA provides user-facing functionalities to receive, verify, and store payments on the device as well as to
submit the payments to the server whenever the client goes online. In case of a TEE-enabled client, the UA
also interacts with the TA to provide wallet operations to the user, such as creating new oine payments,
adding/collecting received payments into the secure wallet, etc. (see Section 2.3 for more details).
OPS Components. Our OPS consists of the following four main components:
OPS Server TA: Deployed on the server and provides the functionalities to register and set up client
devices and manage client accounts.
OPS Sender UA: Deployed on senders device and provides the OPS user interface to create oine
payments by interacting with the OPS TA, and to interact with the server to register the UA and the
TEE.
OPS Receiver UA: Deployed on the receivers device and provides the OPS user interface to receive and
verify oine payments, and to interact withS to register the UA and claim oine payments. This UA
does not interact with any TEE. If the receiver is also wishing to receive money from another client,
then she needs to deploy the OPS Receiver UA on her device.
OPS TA: Deployed on the senders secure device (within TEE) and provides OPS-specic functional-
ities to securely access the secure device and manage the clients oine balance. We denote the TA
deployed on client As device byTA.
5
Setup Protocol. Our OPS protocol requires both clients to register withS during a one-time, online setup
to establish asymmetric cryptographic keys that are later used to issue and verify oine payments. The
online setup also allowsA to initialize her TEE jointly byS and DAs manufacturer. The TEE setup consists
of three phases: (1) Remote attestation to allow either the manufacturer orS to remotely verify the validity
of the TEE stack; (2) TA provisioning to allow either the manufacturer orS to securely deploy a TA inside
TEE; and (3) TA registration to allow the TA to establish a signing key pair, register it withS, and obtain a
certicate attesting to the validity of the key pair. See Section 3.1 for the complete description of the setup
protocol.
Deposit Protocol. Client A needs to initially deposit funds into her secure device when she is online to
be able to send oine payments later. Namely,A requests server S to deposit an amount of money from
her online balance stored at S into her oine balance stored in TA. The server responds with a signature
on showing that was deducted from As online balance. The client TA veries the signature with the
servers public verication key and adds to the oine balance stored in TA. See Section 3.4 for details.
Oline Payment Protocol. An oine payment is initiated by the receiver B who sends a payment re-
quest to A, including Bs certicate in the request. Upon receiving the request, A invokes TAPay to se-
curely deduct the payment amount from TAs balance and create a signed payment message containing
the payment amount and the certicates of both clients. A sends to B who veries As signature and her
certicate, and checks that the payment containsBs certicate as the recipient. If all checks pass,B accepts
the payment and stores on his device. Note that by deducting the payment amount from As balance
(which is stored on the TEE storage), the TEE prevents double spending of that amount. See Section 3.5
for details.
Claim Protocol. If B wants to add the amount of that he received oine from A to his online balance
stored at S, he can invoke the Claim protocol in which S veries the validity of and checks if it was not
previously marked as spent using a payment log stored by S. If all checks pass, S adds the amount of to
Bs online balance and adds to the log. See Section 3.6 for details.
Collect Protocol. Imagine that B also has a secure device with TB set up similar to what was described
before. If B wishes to make an oine payment out of the money he previously received infrom A without
going online, then he can invoke the Collect protocol to add the money in into TBs balance. This allows
B to spend the funds oine in exactly the same way A made the oine payment . See Section 3.6 for
details.
Withdraw Protocol. If A wishes to move funds from TA to her online balance stored at S, then she can
invoke the Withdraw protocol which invokes TAWithdraw to deduct the funds from TA and return a
message signed with TAs signing key. The client then forwards the signed withdraw message to S who
adds the fund to As online balance after verifying the signature. See Section 3.4 for details.
Replay/Rollback Protection. To protect against malicious intermediaries (such as a malicious UA) re-
play the messages exchanged between S and TA as well as between A and B, each party maintains
monotonically-increasing counters that are incremented after every round of communication between
a pair of parties. Both S and TA (as well as A and B) include the latest value of their counter in their signed
messages so that the receiver can verify the uniqueness and ordering of all messages according to their
local counter which is synchronized after every exchange.
6
2 Our Model
Consider a group of clients ABC who can communicate with each other by exchanging messages
through a communication network. We assume that a secure communication infrastructure is in place,
that is, all parties may interact and send messages to each other in a secure way. In particular, this means
that when a party communicates with another, the receiver of the communication will be able to ascertain
the authenticity and validity of said communication.
Every client, say A, is associated with a non-negative numeric value known as its wallet balance (or
simply balance) balA indicating the amount of money possessed by A. A payment is represented in the
form : A

 !B indicating a transfer of amount of money from client A (aka, the sender) to client B
(aka, the receiver). A payment protocol is a protocol that processes a payment : A

 !B by updating the
clients balances correspondingly, i.e.,balA = balA and balB = balB . A payment is called authentic
if and only if the senders balance at the time of payment is greater than or equal to. A payment system
PS consists of a network of clients who can verify the authenticity of any payment within PS through a
designated authority, referred to as server S.
2.1 Problem Denition
An oine payment system (denoted by OPS) is a payment system that enables any pair of clients to pay
each other while both are oine from S. More precisely, any client A is associated with an online balance
onBalA and an oine balance oBalA. Given a payment : A

 !B, an online payment is a protocol that
ensures onBalA = onBalA and onBalB = onBalB . Given a payment : A

 !B, an oine payment
is a protocol that ensures oBalA = oBalA and oBalB = oBalB . The following properties are
enabled by OPS:
Oline Veriability: The receiver must be able to independently verify the authenticity of any
payment without communicating with the server during the payment.
Absolute Finality: Once a payment is complete, the receiver must be instantly guaranteed to own
the transferred funds.
Online Redeemability: A client A must be able to convert any amount oBalA from their
oine balance into their online balance, i.e., oBalA = oBalA and onBalA = onBalA are
executed atomically, and vice versa.
Oline Transitivity: After receiving an oine payment, the receiver must be able to spend the
payment amount (or a portion of it) in the same oine session, i.e., without requiring to go online
to redeem the payment amount and then spend it.
Security: OPS is secure if it has the following properties:
 No Double Spending: No malicious client (or a coalition of them) can spend the same money
more than once.
 Wallet Security: No malicious client (or a coalition of them) can spend/remove money from an
honest clients wallet without her permission.
 Supply Conservation: The total supply of money in the system always stays the same, i.e., a
client can only add/remove money to/from the system via the deposit/withdraw functionalities
provided by the server.
7
If client A wishes to spend her money oine, then she must have a TEE-enabled secure device DA to
store her oine balanceoBalA securely. The balance can only be modied by theOPS trusted application
TA stored in DA. The authenticity of such modications are enabled via digital signatures generated byTA
using a secret key skA stored securely inside DA. If the client does not want to spend money oine, then
she does not require any secure device.
2.2 Threat Model
We assume all parties communicate with each other via secure and authenticated communication chan-
nels. We consider a probabilistic, polynomial-time adversary who can corrupt any client in order to (1)
prevent the protocol from achieving its dened properties; and (2) counterfeit money, for example, by
double-spending the clients money or forging new money. A corrupt client may do so by arbitrarily tam-
pering with and/or blocking messages exchanged between the server and the clients TEE. We assume that
uncorrupt clients employ standard authentication mechanisms such as password and biometrics to prevent
unauthorized access to their device in order to spend and/or erase their money without their approval. We
nally assume that the server is fully trusted.
2.3 TEE Model
A TEE is an isolated execution environment with its own protected hardware resources (e.g., processor
memory, and peripherals) as well as a software stack consisting of an operating system and trusted pro-
grams, known astrusted applications (TAs), to access the TEE hardware resources securely [16,17]. The iso-
lation provides strong integrity and condentiality guarantees, where integrity ensures that unauthorized
users cannot change the code of a TA or its behavior, while condentiality guarantees that unauthorized
access to private TA data is prohibited. The trusted OS provides API access for external programs, known
as untrusted applications (UAs) , to call and execute public TA functions within the TEE while restricting
external access to the rest of the TEE.
In practice, there are dierent TEE architectures depending on the platform they run and the hardware
that provides the isolation. In this paper, we target oine payments for mobile devices; therefore, we
adopt GlobalPlatform (GP) [18], a standardized TEE model adopted by ARM TrustZone technology [19,20]
which itself is used in most Android smartphones today. As shown in Figure 1, the GP model provides a
standardized API for UAs in the non-secure world (aka, the rich execution environment REE ) to interact
with the isolated TAs via the trusted OS. We now describe GPs secure storage model that allows us to
protect against OPS TA state rollback.
TEE Replay/Rollback Protection. Throughput this paper, we assume that the OPS TA has access to
a secure storage to store its state, ensuring that the state cannot be rolled back by the adversary. The
GP specication mandates the possibility to store general-purpose data and key material within a TEE
with integrity, condentiality, and atomicity1 guarantees [21]. Typically, a replay-protected memory block
(RPMB) partition2 on an eMMC storage (e.g., the phones persistent storage) is used to store TAs data
securely [22, 23]. Any data written on the RPMB is protected against man-in-the-middle replay/rollback
attacks using a monotonically-increasing counter (MIC) maintained by a dedicated hardware, known as the
RPMB engine . The engine increments the MIC after every write to the RPMB and uses message authen-
tication codes (MACs) to verify the validity of the write command by checking that (1) the counter was
increased, and (2) the MAC that was sent by the sender (e.g., the TA) is identical to the MAC that the
RPMB engine generated using its latest value of MIC. Finally, every read from RPMB is MAC-checked by
1 Atomicity means that either the entire write operation completes successfully or no write is done.
2 The RPMB partition is typically 4 MB in size [22].
8
Untrusted 
App
Untrusted 
App
Untrusted 
App
Trusted 
App
Trusted 
App
Trusted 
App
Embedded OS Trusted OS
Protected Hardware 
Resources
Rich Execution Environment
Untrusted World
Trusted Execution Environment
Trusted World
Hardware
Figure 1: Our TEE Model
the reader (e.g., the TA) using the latest value of MIC maintained by the reader. For more details, we refer
the reader to [22]. The GP specication also allows a secure storage to be implemented on the REE (i.e.,
non-secure) le system as long as suitable cryptographic protection is applied, which must be as strong as
the means used to protect the TEE code and data itself [21].
3 The OPS Protocol
We now describe the OPS protocol explicitly. We break down the protocol to its components and explain
each thoroughly.
3.1 Client Setup
Every client (TEE-enabled or not) needs to participate in a one-time setup protocol to register her device
with the server (i.e., establish cryptographic keys and certicates) and to initialize her devices TEE stack
in case of a TEE-enabled device. To register with the server, the client generates a local signing key pair
denoted by vkskand submits the verication key to the server. In return, the server initializes the
clients account information and returns a certicate denoted bycert to the client.
The certicate is essentially a signature by the server on the clients verication key so that the client
can later prove to other entities that her device is registered with the server. The server maintains a registry
(denoted by SRegistry) of all registered clients. When a new client registers herself with the server, the
verication key of the client is added to this registry. This allows the server to keep track of registered
clients in the future to catch duplicate and bogus users. The server also stores the online balance (denoted
by onBal) of each registered client. When a new client registers herself with the server, the server initializes
an online balance of 0 for the client. The formal description of this protocol is presented in Figure 2.
9
Variable Description Scope
SRegistry Server Ss registry of valid UA certicates S
SonBalA Client As online balance stored atS S
SiA Client As index maintained byS S
DA Client As secure device/hardware A
TA Client As trusted application deployed onDA A
skSvkS Server Ss signing key pair ( S, Global)
skAvkA Client As signing key pair ( A, Global)
TAskTAvk TAs signing key pair ( TA, Global)
certA Certicate for client A consisting of vkA and a signature on it by S certify-
ing that vkA was issued by S
Global
TAcert Certicate for TA consisting of TAvk and a signature on it by S certifying
that TAvk was issued by S
Global
TAi Client As server index maintained byTA TA
TAj Client As payment index maintained byTA TA
TAbal ClientsAs oine balance TA
TAinPaymentLog List of oine payments received by TA ATAS
amount Amount money transferred by payment Holder of 
sender Certicate of the sender of payment Holder of 
receiver Certicate of the receiver of payment Holder of 
index Index of payment Holder of 
time Time when payment was created Holder of 
type Type of payment (Basic or Conditional) Holder of 
Function Description Scope
H Outputs a cryptographic hash of Global
Signsk Outputs a signature of signed with signing key sk Global
SigVerify vk Outputs 1 i signature over using verication key vk is valid Global
CertVerifycertvkS Outputs 1 i SigVerifycertvkcertsigvkS?= 1 Global
TACertVerifycertvkS Outputs 1 i SigVerifycertvkTAcertsigvkS?= 1 Global
OEMVerifyvkcertvkD Outputs 1 i SigVerifyvkSecure DevicekMcertvkD?= 1 Global
TADeposit Deposits amount of money into client As secure hardwareTA TA
TAWithdraw Withdraws amount of money from client As secure hardwareTA TA
TAPay Debits amount of money from TA and outputs a payment TA
TACollect Credits a payment into TAs balance TA
Table 1: Protocol Notations
10
Client Registration Protocol
Client A requests server S create an account for her.
1. A sends RegisterClientvkAto S, where vkAskA KeyGen1.
2. Upon receiving RegisterClientvkA, S performs the following steps:
(a) Abort if vkA2 SRegistry;
(b) Add vkA?to SRegistry;
(c) SonBalA 0;
(d) Create certA such that certAvk vkA and certAsig SignvkAskS;
(e) Send certA to A.
Figure 2: Client Registration Protocol
We now describe how a TEE-enabled client can set up its TEE (according to the GP specication) using
remote attestation and TA provisioning.
TEE Remote Attestation. The rst step to set up a TEE is to obtain an attestation from the original
equipment manufacturer (OEM) of the TEE to convince any verier that the TEE hardware and the trusted
OS are authentic. At a high-level, this is ensured by a read-only memory (ROM), and a device specicdevice
key-pair DvkDsk. Both the ROM and the device keys are embedded into the hardware by the OEM. The
trusted OS provides a signature (usingDsk from the ROM) on the TEE binaries using a method we denote
 along with Dvk to the remote party who forwards them to the OEM for verication. Since
OEM knows the contents of the TEE stack, it can verify the signature, and hence attest to the authenticity
of the TEE using a method we denote OEMVerify.
OPS TA Provisioning. Once the TEE is authenticated via remote attestation, the verier needs to ensure
that the OPS TA program (as shown on Figure 4) is provisioned (i.e., deployed) properly inside the TEE.
This can be done via either local or remote provisioning [18]. In local provisioning, the OEM ships TA
binaries on the device as part of the TEE software stack. In remote provisioning, a trusted party (e.g.,
Trustonic [24]) deploys the TA to the TEE remotely after the TEE has been authenticated via the remote
attestation process. This is done by rst establishing a secure channel with the TEE using the devices
verication key, and then transmitting the TA binaries to the TEE over the secure channel. To ensure the
TA is deployed properly, the TEE signs a hash of the binary with Dsk and returns the signature to the
trusted party for verication.
3.2 OPS TA Registration
After registering with the server, TEE-enabled clients will need to perform two key steps in order to ini-
tialize their TEE. First, their TEE must be authenticated by means of (remote) attestation. Next, the OPS
TA (as shown in Figure 4) must be provisioned within their TEE. After the TEE is validated and the OPS
TA is setup via provisioning phase, the clients device and the OPS TA instance need to be registered with
the server. To do this, the OPS TA rst generates a signing key pair denoted TvkTsk, and returns to
the clients device the verication key as well as the remote attestation. This process is described by the
method Init described in the OPS TA program in Figure 4.
Next, the client transmits the TAs verication key and the attestation, along with its own device in-
formation to the server. The server, after verifying the attestation (using OEMVerify), certies the key
11
by signing it with the servers secret key and returning it to the device. The signed verication key is a
certicate showing that the OPS TA key is generated by a genuine TEE and is registered with the server.
Whenever this device makes a payment, it transmits the certicate along with other payment informa-
tion, so that the receiver can independently verify the validity of the payment using the servers public
(verication) key.
The certicate is also required to activate the clients TEE for oine payments. That is, only after
receiving the certicate from the server ascertaining that it has been registered with the server will the
OPS TA in the TEE perform any of its functions (other thanInit). This check is performed by the method
CertInit described in the OPS TA program (Figure 4). Specically, initializing the variable Tcert by the
method CertInit in the OPS TA is necessary for the invocation of other methods.
The server initializes a counter (denoted by i) for each OPS client. The OPS TA also maintains an in-
ternal variable denoted by Ti. Our protocol ensures that the two counters are in sync with one another.
While the value of the counter would denote the number of deposits or withdrawals that have been per-
formed by the client, the role of this counter is to distinguish various deposits (converting online funds to
oine funds) and withdrawals (converting oine funds to online funds) and protect against replay attacks
(e.g., replaying a deposit would allow a client to create oine funds out of thin air). This will be explained
in further detail in Section 3.4.
The server makes use of its registry to ensure that the client has registered herself before the deposit
step. The server also uses the registry to tag the TEE being registered along with the client who is regis-
tering it, by storing the pair vkTvkin its registry. The formal description of this protocol is presented
in Figure 3.
TA Registration Protocol
Client A requests server S to register the instance of the OPS TA, denoted by TA, on her device DA. After the
secure boot sets TEE, the following protocol is executed between A and S.
1. A obtains TAvk TAInitand sends TARegisterDAvkTAvkvkAto S.
2. Upon receiving TARegisterDAvkTAvkvkAfrom A, server S does the following steps:
(a) Abort if any of the following conditions is true:
 vkA? SRegistry;
 OEMVerifyTAvk DAvk 1;
(b) iA 0;
(c) Create a certicate cert such that
certvk TAvk;
certsig SignTAvkTAskS.
(d) Send certto A;
(e) Replace vkA?with vkAcertvkin SRegistry.
3. Upon receiving certfrom S, client A invokes TACertInitcert.
Figure 3: TA Registration Protocol
3.3 OPS TA Program
In Figure 4, we present the methods provided by our OPS TA to the TEE-enabled client devices. We rst
briey describe them. Note that the workings and the roles of the methods Init and CertInit have
already been discussed in Sections 3.1 and 3.2.
12
Init: Initializes the OPS TA, generates a key-pair along with attestation; this is the rst method
that must be invoked.
CertInit: Processes certicate from the server; this is the second method that must be invoked,
after which, other methods can be executed.
Deposit: Converts online funds into oine funds, increases the oine balance.
Withdraw: Converts oine funds into online funds, decreases the oine balance.
Pay: Creates an oine payment object.
Collect: Veries an oine payment and applies it to the oine balance by increasing it with the
payment amount.
Get-Balance: Returns the current oine balance stored inside the TEE storage.
After registering herself with the server and provisioning the OPS TA on her TEE, the client invokes
the Init method of the OPS TA. Using the results from the OPS TA, the client can then register her TEE
with S, obtain the certicate fromS, and invoke the CertInit method of the OPS TA. Now, the client can:
Convert some/all of her online funds into oine funds in her OPS TA (by invoking the deposit
protocol described in Section 3.4 which will involve invoking the Deposit method of the OPS TA);
Use oine funds to make oine payments (by invoking the oine payment protocol described
Section 3.5 which will involve invoking the Pay method of the OPS TA);
Verify oine payments made to her either oine with her OPS TA (by invoking the collect protocol
described Section 3.6 which will involve invoking the Collect method of the OPS TA) or online
with the server (by invoking the claim protocol described Section 3.6);
Convert some/all of her oine funds into online funds (by invoking the withdraw protocol described
Section 3.4 which will involve invoking the Withdraw method of the OPS TA).
With the overall ow of operations in mind, we now describe the OPS TA program in more detail. The
OPS TA maintains some variables whose functions are as follows:
 TvkTskis the singing key-pair used to authenticate outputs of the OPS TA.
Tbal is the oine balance that is maintained within the OPS TA.
Tcert is the certicate issued by the server on registering the TEE. This certicate allows the OPS
TA to be convinced that the TEE has been registered with the server. It is also used by the OPS
TA when it generates oine payments to identify itself as an authentic registered sender of oine
funds.
TinPaymentLog is the log of oine payments received from other users. It is used to protect a client
from a malicious sender who may be replaying a previous payment in an attempt to double-spend.
Ti is a counter for deposits and withdrawals. The role and workings of this counter were alluded to
briey in Section 3. Recall that the server also maintains a copy of this counter and the two copies
are kept in sync with one another. It is used to prevent replay attacks in the context of deposits and
withdrawals. Further details are described in Section 3.4.
13
Tj is a counter for payments. It is used to make every payment unique. This (in conjunction with
the payment log inPaymentLog) prevents a client from replaying a previous payment in an attempt
to double-spend.
We now describe in detail the various sub-protocols that are involved in our OPS protocol.
3.4 Deposit and Withdraw Protocols
In the deposit protocol presented in Figure 5, the client converts some/all of her online funds into oine
funds. That is, the client deducts some amount from her online balance, as maintained by the server, and
deposits the amount to her oine balance which is maintained by the OPS TA within her device. The
withdraw protocol presented in Figure 6 works in the opposite direction converting oine funds into
online funds. That is, the client withdraws some amount from her oine balance and transfers it to the
server to add the amount to her online balance.
The deposit protocol works as follows. The client wishing to deposit an amount of online funds
into her oine balance, sends the request Depositto the server. The server on identifying the client3
checks that the client has sucient (greater than ) online funds. If so, the server deducts an amount of
 from the clients online balance and generates a deposit conrmation that contains the amount . Aside
from the amount, the conrmation contains two other key pieces of information. The rst is the counter
i for deposits and withdrawals, and the second is a signature by the server on Tvk, and i. We will
describe the need for each of these ahead. On receiving the deposit conrmation, the client can invoke the
Deposit method of the OPS TA with the conrmation. The method checks that the its local copyTi is in
sync with that of the server (technically, they would be o by1 at this stage, but equal to each other once
Deposit completes) and that the signature is valid. If so, it increments the oine balance by and syncs
up Ti.
We now describe the role of i and . The counter i is used to uniquely identify deposits and with-
drawals and thus prevent a client using a particular deposit conrmation more than once. In particular, if
a client attempts to invoke the method Deposit using a particular deposit conrmation more than once,
the counter i would be out of sync with that of the server that is present in the conrmation itself. But
what if the client attempts to spoof the value of i in the deposit conrmation in order to make it seem as
though it is in sync? This is prevented by the signature .
Concretely, the presence of authenticates the conrmation sent by the server. It is not possible for
the client to modify the particulars of the conrmation (the TEE, the amount or i) without resulting in an
invalid signature in the conrmation. By signing on Tvk, deposit conrmations can only be processed by
one single (intended) client TEE. By signing on , the TEE is convinced of the authenticity of the deposit
amount. By signing on i, as explained before, a deposit conrmation cannot be replayed in an attempt to
generate oine funds out of thin air. The formal description of this protocol is presented in Figure 5.
3The explicit reference to these details has been omitted in the presentation in Figure 5. This would involve the client identi-
fying themselves for instance using the certicate or verication key which the server could check for in its registry. The server
would also need to determine if the client has registered her TEE which would be necessary in order to deposit online funds
oine. The client would have to explicitly identify their TEE which the server could then check for in its registry.
14
OPS Trusted Application
Init:
1. TvkTsk KeyGen1; Tbal 0; Tcert = ?; TinPaymentLog ?; Ti 0; Tj 0;
2. Tvk
3. Output Tvk.
CertInitcert:
1. Abort if TACertVerifycertTvkS 1.
2. Tcert cert.
DepositiS:
1. Abort if Tcert = ?or i Ti 1 or SignVerifyTvk iSvkS 1;
2. Tbal Tbal ;
3. Ti Ti 1.
Withdraw:
1. Abort if Tcert = ?or Tbal;
2. Tbal = Tbal ;
3. Ti = Ti 1;
4. Output Ti, where = SignTiTsk.
Payreceiver:
1. Abort if Tcert = ?or Tbal ;
2. Tbal Tbal ;
3. Tj Tj 1;
4. amount ; sender Tcert; receiver receiver; index Tj;
5. Output , where sig SignamountsenderreceiverindexTsk.
Collect:
1. Abort if Tcert = ?or PayVerify 1 or receiver Tcert or 2TinPaymentLog;
2. Tbal Tbal amount;
3. Append to TinPaymentLog.
Get-Balance:
1. Abort if Tcert = ?;
2. Output TbalTi, where = SignTbalTiTsk.
Figure 4: OPS Trusted Application
15
Deposit Protocol
Client A requests server S to deposit an amount of money from her online balance stored atS into her oine
balance stored in TA.
1. A sends Depositto S.
2. Upon receiving Depositfrom A, server S does the following steps:
(a) Abort if SonBalA;
(b) SonBalA SonBalA ;
(c) SiA SiA 1;
(d) Send DepositConrmed SiAto A, where SignTAvk SiASskS.
3. Upon receiving DepositConrmed ifrom S, client A invokes TDepositi.
Figure 5: Deposit Protocol (Online !Oine)
The withdraw protocol works in exactly the same way as the deposit protocol, only in reverse. The
client wishing to withdraw an amount of oine funds into her online balance, invokes the Withdraw
method of the OPS TA with the amount . The OPS TA checks that the client has sucient (greater than
) oine funds. If so, the OPS TA deducts an amount of from the clients oine balance and generates a
withdraw conrmation that contains the amount . As in the case of the deposit protocol, the withdraw
conrmation also contains the counter i and a signature by the OPS TA on and i. We will describe the
need for each of these ahead.
The client on receiving the withdraw conrmation, sends the requestWithdraw ito the server.
The server on identifying the client checks that the its local copy Si is in sync with that of the OPS
TA and that the signature is valid. If so, it increments the online balance by and syncs up Si. The
counter i prevents a client using a particular withdraw conrmation more than once. The presence of 
authenticates the conrmation sent by the OPS TA. It is not possible for the client to modify the particulars
of the conrmation (the amount or i) without resulting in an invalid signature in the conrmation. By
signing on , the TEE is convinced of the authenticity of the deposit amount. By signing oni, as explained
before, a withdraw conrmation cannot be replayed in an attempt to generate online funds out of thin air.
The formal description of this protocol is presented in Figure 6.
Withdraw Protocol
Client A requests server S to withdraw an amount of money from her oine balance maintained by TA into
her online balance maintained by S.
1. Client A sends Withdraw ito S, where i TAWithdraw.
2. Upon receiving Withdraw ifrom A, server S performs the following steps:
(a) Abort if i SiA 1 or SigVerifyi TAvk 1;
(b) SonBalA SonBalA ;
(c) SiA SiA 1;
(d) Send WithdrawConrmedto A;
Figure 6: Withdraw Protocol (Oine !Online)
16
3.5 Oline Payment Protocol
In the oine payment protocol presented in Figure 7, a client makes an oine payment to an-
other client in the following way. First, the receiver of the payment sends a payment request
RequestPayment receiverto the sender of the payment. The payment request contains the payment
amount as well as the certicate of the receiver (denoted by receiver). Upon receiving a payment request,
the sender invokes the methodPay of the OPS TA usingand receiver. The OPS TA checks that the sender
has sucient (greater than ) oine funds. If so, the OPS TA deducts an amount of from the clients of-
ine balance and generates a payment conrmation that contains the amount . Aside from the amount
, the payment conrmation also contains the certicates of the sender (recall, Tcert) and the receiver
(recall, receiver), the payment counter j and a signature by the OPS TA on all of these particulars.
On receiving the payment conrmation, the receiver checks that the payment is valid usingPayVerify
which veries the certicates and. In addition, the receiver checks that the payment was intended for her
(i.e., matches the receiver) and that it is a fresh payment, i.e., the receiver can maintain a loginPaymentLog
of payments she has received, much like the OPS TA does, in order to prevent malicious senders from re-
playing payments in an attempt to double-spend. If all checks pass, the receiver is convinced of receiving
the payment at this point, the receiver is ensured to obtain the payment funds. The receiver adds this
payment to her log of payments and sends a conrmation message ReceivedPaymentto S. This com-
pletes the portion of the protocol that involves the sender making an oine payment.
In order to obtain the payment funds, the receiver must either invoke theCollect method of the OPS
TA, or she is not a TEE-enabled client, she may engage in the claim protocol. Further details regarding this
are described in Section 3.6. It is to be noted that oine payments made to TEEs must be collected and not
claimed, while payments made to clients must be claimed and not collected. We now describe the need for
the various particulars of the payment conrmation. The presence of the sender and receiver certicates
in the payment conrmation convince the receiver that the payment is coming from a registered sender
and that the payment has indeed been made to herself. The counter j prevents a client using a particular
payment conrmation more than once. Notice that the Pay method of the OPS TA increments j. Thus,
every payment conrmation generated by a given TEE is unique (at the bare minimum, the value of j
would dier between them).
The payment conrmation also contains the sender certicate, this also means that every payment
conrmation every generated is unique (either the sender certicate would dier, and if not,j would). The
presence of authenticates the conrmation sent by the OPS TA. It is not possible for the client to modify
the particulars of the conrmation (the amount, sender and receiver certicates or j) without resulting in
an invalid signature in the conrmation. By signing onand the certicates of the sender and the receiver,
the authenticity of the payment amount and parties involved in the payment is guaranteed. By signing on
j, as explained before, a payment conrmation cannot be replayed in an attempt to double-spend oine
funds. The formal description of this protocol is presented in Figure 7.
17
Oline Payment Protocol
Client B requests client A to send B a payment : A

 !B transferring amount of money from A to B while
both clients are oine from S.
1. Client B sets receiver TBcert if TB ?. Otherwise, receiver certB.
He then sends RequestPayment receiverto A.
2. Upon receiving RequestPayment receiverfrom B, client A sends TAPayreceiverto B.
3. Upon receiving from A, client B performs the following steps:
(a) Abort if any of the following conditions is true:
 PayVerify 1,
 receiver receiver, or
 2BinPaymentLog;
(b) B adds to BinPaymentLog and sends ReceivedPaymentto A;
(c) If receivertype = TA, thenB calls TBCollect;
(d) Otherwise, B engages in the Claim protocol with S (Figure 9) as soon as B is online.
Figure 7: Oine Payment Protocol
PayVerify:
Return 1 if and only if all of the following conditions hold:
1. TACertVerifysender
?
= 1, and
2. SigVerifyamountsenderreceiverindexsigsendervk
?
= 1.
Figure 8: Payment Verication Method
3.6 Claim and Collect Protocols
Once a client has obtained a payment conrmation, they can obtain the funds by either invoking the
Collect method of the OPS TA, or if she is not a TEE-enabled client, she may engage in the claim protocol
presented in Figure 9 as soon as she is online. As noted in Section 3.5, oine payments made to TEEs must
be collected and not claimed, while payments made to clients must be claimed and not collected. This is
to prevent a malicious client from collecting and claiming a single payment conrmation in an attempt to
generate online or oine funds out of thin air. Thus, a single payment conrmation may only be either
collected or claim, but not both. This means that it is sucient to ensure that a single conrmation cannot
be collected more than once, nor claimed more than once.
Collect Protocol. A client can collect a payment by invoking the Pay method of the OPS TA using
the payment conrmation. The OPS TA checks that the payment is valid (performed using PayVerify
which veries the certicates and ), that it was intended for itself (matching receiver) and that it is a
fresh payment (the OPS TA maintains a loginPaymentLog of payments it has received in order to prevent
malicious senders from replaying payments in an attempt to double-spend; this means that a payment
cannot be collected more than once). If all checks pass, the OPS TA increments the oine balance by 
and adds this payment to its log of payments.
18
Claim Protocol. A client can claim a payment by engaging in the claim protocol as shown in Figure 9.
The client wishing to claim a paymentsends the request Claimto S who checks that the payment is
valid and that it is a fresh payment. To achieve this,S maintains a loginPaymentLog of payments that have
been claimed, much like the OPS TA does, in order to prevent malicious clients from replaying payments
in an attempt to generate online funds out of thin air. This means that a payment cannot be claimed more
than once. If all checks pass, S increments the online balance by and adds this payment to its log of
payments. Finally, S sends a conrmation message ClaimConrmedto the client.
Claim Protocol
Client B submits an oine payment that he received from A to server S to have the money credited into his
online balance stored at S.
1. B sends Claimto S.
2. Upon receiving Claimfrom B, server S performs the following steps:
(a) Abort if any of the following conditions is true:
 receivertype UA;
 PayVerify 1;
 2SpaymentLog;
(b) SonBal receiver SonBal receiver amount;
(c) Add to SpaymentLog;
(d) Send ClaimConrmedto B.
Figure 9: Claim Protocol (Oine !Online)
References
[1] United States House of Representatives Committee on Financial Services: Task Force on Finan-
cial Technology. Inclusive banking during a pandemic: Using fedaccounts and digital tools
to improve delivery of stimulus payments. https://www.congress.gov/116/meeting/house/
110778/witnesses/HHRG-116-BA00-Wstate-GiancarloJ-20200611.pdf , June 2020. (Accessed
on 09/15/2020).
[2] European Parliament. Crypto-assets: Key developments,regulatory concerns and responses.
https://www.europarl.europa.eu/RegData/etudes/STUD/2020/648779/IPOL_STU(2020)
648779_EN.pdf, April 2020. (Accessed on 09/15/2020).
[3] G7 Working Group on Stablecoins. Investigating the impact of global stablecoins. https://www.
bis.org/cpmi/publ/d187.pdf, October 2019. (Accessed on 09/15/2020).
[4] Discussion paper - central bank digital currency: Opportunities, challenges and
design. https://bankofengland.co.uk/-/media/boe/files/paper/2020/
central-bank-digital-currency-opportunities-challenges-and-design.pdf , 03 2020.
(Accessed on 06/29/2020).
[5] Colm Fulton. Sweden starts testing worlds rst central bank digital cur-
rency - reuters. https://reuters.com/article/us-cenbank-digital-sweden/
sweden-starts-testing-worlds-first-central-bank-digital-currency-idUSKBN20E26G ,
02 2020. (Accessed on 06/29/2020).
19
[6] China aims to launch the worlds rst ocial digital currency | nance & economics
| the economist. https://economist.com/finance-and-economics/2020/04/23/
china-aims-to-launch-the-worlds-first-official-digital-currency , 04 2020. (Ac-
cessed on 06/29/2020).
[7] Stephen S. Wu, Randy V. Sabett, Dr. Santosh Chokhani, Dr. Warwick S. Ford, and Charles (Chas) R.
Merrill. Internet X.509 Public Key Infrastructure Certicate Policy and Certication Practices Frame-
work. RFC 3647, November 2003.
[8] The Fed - comparing means of payment: What role for a central bank digi-
tal currency? https://www.federalreserve.gov/econres/notes/feds-notes/
comparing-means-of-payment-what-role-for-a-central-bank-digital-currency-20200813.
htm, August 2020. (Accessed on 09/22/2020).
[9] Raphael Auer and Rainer Bhme. The technology of retail central bank digital currency. https:
//www.bis.org/publ/qtrpdf/r_qt2003j.pdf, March 2020. (Accessed on 09/22/2020).
[10] Payment and settlement systems report - Annex Bank of Japan reports and research papers.
https://www.boj.or.jp/research/brp/psr/data/psrb200702.pdf, July 2020. (Accessed on
09/22/2020).
[11] Card acceptance guidelines for Visa merchants. https://usa.visa.com/dam/VCOM/download/
merchants/card-acceptance-guidelines-for-merchants.pdf , 2015. (Accessed on
06/30/2020).
[12] Mastercard transaction processing rules. https://mastercard.us/content/dam/mccom/global/
documents/transaction-processing-rules.pdf, 12 2019. (Accessed on 06/30/2020).
[13] Square Editorial Team. Oine credit card processing - accept credit cards oine. https:
//squareup.com/us/en/townsquare/offline-credit-card-processing , 2020. (Accessed on
11/18/2020).
[14] Felix Wu. No easy answers in the ght over iphone decryption. Commun. ACM, 59(9):2022, August
2016.
[15] Sarah Allen, Srdjan Capkun, Ittay Eyal, Giulia Fanti, Bryan Ford, James Grimmelmann, Ari
Juels, Kari Kostiainen, Sarah Meiklejohn, Andrew Miller, Eswar Prasad, Karl Wst, and Fan
Zhang. Design choices for central bank digital currency policy and technical considerations.
https://www.brookings.edu/wp-content/uploads/2020/07/Design-Choices-for-CBDC_
Final-for-web.pdf, July 2020. (Accessed on 12/10/2020).
[16] M. Sabt, M. Achemlal, and A. Bouabdallah. Trusted execution environment: What it is, and what it
is not. In 2015 IEEE Trustcom/BigDataSE/ISPA , volume 1, pages (5764), 2015.
[17] G. Arfaoui, S. Gharout, and J. Traor. Trusted execution environments: A look under the hood. In
2014 2nd IEEE International Conference on Mobile Cloud Computing, Services, and Engineering , pages
259266, 2014.
[18] GlobalPlatform the Trusted Execution Environment: Delivering enhanced security at a lower
cost to the mobile market. https://globalplatform.org/wp-content/uploads/2018/04/
GlobalPlatform_TEE_Whitepaper_2015.pdf, June 2015. (Accessed: 2020-06-21).
20
[19] ARM TrustZone. https://developer.arm.com/ip-products/security-ip/trustzone. (Ac-
cessed: 2020-06-21).
[20] Sandro Pinto and Nuno Santos. Demystifying ARM TrustZone: A comprehensive survey. ACM
Comput. Surv., 51(6), January 2019.
[21] GLOBALPLATFORM. GlobalPlatform: TEE internal API specication". https://globalplatform.
org/wp-content/uploads/2018/06/GPD_TEE_Internal_Core_API_Specification_v1.1.2.
50_PublicReview.pdf.
[22] Einav Zilberstein and Adi Klein. Western digital whitepaper: e.MMC security methods.
https://documents.westerndigital.com/content/dam/doc-library/en_us/assets/
public/western-digital/collateral/white-paper/white-paper-emmc-security.pdf ,
July 2017.
[23] Liang Cai. Guard your data with the Qualcomm Snapdragon mo-
bile platform. https://www.qualcomm.com/media/documents/files/
guard-your-data-with-the-qualcomm-snapdragon-mobile-platform.pdf , April 2019.
[24] Trustonic: World leading embedded cybersecurity & patented technology Trustonic. https://www.
trustonic.com/. (Accessed on 11/24/2020).
Disclaimers
Case studies, comparisons, statistics, research and recommendations are provided AS IS and intended for informational purposes
only and should not be relied upon for operational, marketing, legal, technical, tax, nancial or other advice. Visa Inc. neither makes
any warranty or representation as to the completeness or accuracy of the information within this document, nor assumes any liability
or responsibility that may result from reliance on such information. The information contained herein is not intended as investment or
legal advice, and readers are encouraged to seek the advice of a competent professional where such advice is required. All trademarks
are the property of their respective owners, are used for identication purposes only, and do not necessarily imply product endorsement
or aliation with Visa.
21